;; Object internet/
;; SEMANTICDB Tags save file
(semanticdb-project-database-file "internet/"
  :tables
  (list
    (semanticdb-table "defer.py"
      :major-mode 'python-mode
      :tags 
        '( ("\"\"\"
Support for results that aren't immediately available.

Maintainer: Glyph Lefkowitz

@var _NO_RESULT: The result used to represent the fact that there is no
    result. B{Never ever ever use this as an actual result for a Deferred}.  You
    have been warned.

@var _CONTINUE: A marker left in L{Deferred.callback}s to indicate a Deferred
    chain.  Always accompanied by a Deferred instance in the args tuple pointing
    at the Deferred which is chained to the Deferred which has this marker.
\"\"\"" code nil nil [124 627])
            ("__future__" include nil nil [629 693])
            ("traceback" include nil nil [695 711])
            ("types" include nil nil [712 724])
            ("warnings" include nil nil [725 740])
            ("sys" include nil nil [741 779])
            ("functools" include nil nil [780 807])
            ("incremental" include nil nil [808 839])
            ("twisted.python.compat" include nil nil [859 908])
            ("twisted.python" include nil nil [909 953])
            ("twisted.logger" include nil nil [954 987])
            ("twisted.python.deprecate" include nil nil [988 1054])
            ("twisted.python._oldstyle" include nil nil [1055 1101])
            ("log" variable nil nil [1103 1117])
            ("AlreadyCalledError" type
               (:superclasses ("Exception")
                :members 
                  ( ("pass" code nil (reparse-symbol indented_block_body) [1161 1165]))                  
                :type "class")
                nil [1120 1166])
            ("CancelledError" type
               (:documentation "
    This error is raised by default when a L{Deferred} is cancelled.
    "
                :superclasses ("Exception")
                :type "class")
                nil [1169 1287])
            ("TimeoutError" type
               (:documentation "
    This error is raised by default when a L{Deferred} times out.
    "
                :superclasses ("Exception")
                :type "class")
                nil [1289 1402])
            ("logError" function
               (:documentation "
    Log and return failure.

    This method can be used as an errback that passes the failure on to the
    next errback unmodified. Note that if this is the last errback, and the
    deferred gets garbage collected after being this errback has been called,
    the clean up code logs it again.
    "
                :arguments 
                  ( ("err" variable nil (reparse-symbol function_parameters) [1418 1421]))                  )
                nil [1405 1778])
            ("succeed" function
               (:documentation "
    Return a L{Deferred} that has already had C{.callback(result)} called.

    This is useful when you're writing synchronous code to an
    asynchronous interface: i.e., some code is calling you expecting a
    L{Deferred} result, but you don't actually need to do anything
    asynchronous. Just return C{defer.succeed(theResult)}.

    See L{fail} for a version of this function that uses a failing
    L{Deferred} rather than a successful one.

    @param result: The result to give to the Deferred's 'callback'
           method.

    @rtype: L{Deferred}
    "
                :arguments 
                  ( ("result" variable nil (reparse-symbol function_parameters) [1793 1799]))                  )
                nil [1781 2434])
            ("fail" function
               (:documentation "
    Return a L{Deferred} that has already had C{.errback(result)} called.

    See L{succeed}'s docstring for rationale.

    @param result: The same argument that L{Deferred.errback} takes.

    @raise NoCurrentExceptionError: If C{result} is L{None} but there is no
        current exception state.

    @rtype: L{Deferred}
    "
                :arguments 
                  ( ("result" variable nil (reparse-symbol function_parameters) [2446 2452]))                  )
                nil [2437 2856])
            ("execute" function
               (:documentation "
    Create a L{Deferred} from a callable and arguments.

    Call the given function with the given arguments.  Return a L{Deferred}
    which has been fired with its callback as the result of that invocation
    or its C{errback} with a L{Failure} for the exception thrown.
    "
                :arguments 
                  ( ("callable" variable nil (reparse-symbol function_parameters) [2871 2879])
                    ("args" variable nil (reparse-symbol function_parameters) [2881 2886])
                    ("kw" variable nil (reparse-symbol function_parameters) [2888 2892]))                  )
                nil [2859 3309])
            ("maybeDeferred" function
               (:documentation "
    Invoke a function that may or may not return a L{Deferred}.

    Call the given function with the given arguments.  If the returned
    object is a L{Deferred}, return it.  If the returned object is a L{Failure},
    wrap it with L{fail} and return it.  Otherwise, wrap it in L{succeed} and
    return it.  If an exception is raised, convert it to a L{Failure}, wrap it
    in L{fail}, and then return it.

    @type f: Any callable
    @param f: The callable to invoke

    @param args: The arguments to pass to C{f}
    @param kw: The keyword arguments to pass to C{f}

    @rtype: L{Deferred}
    @return: The result of the function call, wrapped in a L{Deferred} if
    necessary.
    "
                :arguments 
                  ( ("f" variable nil (reparse-symbol function_parameters) [3330 3331])
                    ("args" variable nil (reparse-symbol function_parameters) [3333 3338])
                    ("kw" variable nil (reparse-symbol function_parameters) [3340 3344]))                  )
                nil [3312 4345])
            ("" code nil nil [4359 4459])
            ("timeout" function (:arguments 
              ( ("deferred" variable nil (reparse-symbol function_parameters) [4472 4480]))              ) nil [4460 4557])
            ("passthru" function (:arguments 
              ( ("arg" variable nil (reparse-symbol function_parameters) [4573 4576]))              ) nil [4560 4594])
            ("setDebugging" function
               (:documentation "
    Enable or disable L{Deferred} debugging.

    When debugging is on, the call stacks from creation and invocation are
    recorded, and added to any L{AlreadyCalledError}s we raise.
    "
                :arguments 
                  ( ("on" variable nil (reparse-symbol function_parameters) [4614 4616]))                  )
                nil [4597 4848])
            ("getDebugging" function (:documentation "
    Determine whether L{Deferred} debugging is enabled.
    ") nil [4851 4969])
            ("_NO_RESULT" variable nil nil [4995 5016])
            ("_CONTINUE" variable nil nil [5017 5037])
            ("Deferred" type
               (:documentation "
    This is a callback which will be put off until later.

    Why do we want this? Well, in cases where a function in a threaded
    program would block until it gets a result, for Twisted it should
    not block. Instead, it should return a L{Deferred}.

    This can be implemented for protocols that run over the network by
    writing an asynchronous protocol for L{twisted.internet}. For methods
    that come from outside packages that are not under our control, we use
    threads (see for example L{twisted.enterprise.adbapi}).

    For more information about Deferreds, see doc/core/howto/defer.html or
    U{http://twistedmatrix.com/documents/current/core/howto/defer.html}

    When creating a Deferred, you may provide a canceller function, which
    will be called by d.cancel() to let you do any clean-up necessary if the
    user decides not to wait for the deferred to complete.

    @ivar called: A flag which is C{False} until either C{callback} or
        C{errback} is called and afterwards always C{True}.
    @type called: L{bool}

    @ivar paused: A counter of how many unmatched C{pause} calls have been made
        on this instance.
    @type paused: L{int}

    @ivar _suppressAlreadyCalled: A flag used by the cancellation mechanism
        which is C{True} if the Deferred has no canceller and has been
        cancelled, C{False} otherwise.  If C{True}, it can be expected that
        C{callback} or C{errback} will eventually be called and the result
        should be silently discarded.
    @type _suppressAlreadyCalled: L{bool}

    @ivar _runningCallbacks: A flag which is C{True} while this instance is
        executing its callback chain, used to stop recursive execution of
        L{_runCallbacks}
    @type _runningCallbacks: L{bool}

    @ivar _chainedTo: If this L{Deferred} is waiting for the result of another
        L{Deferred}, this is a reference to the other Deferred.  Otherwise,
        L{None}.
    "
                :members 
                  ( ("called" variable nil (reparse-symbol indented_block_body) [7040 7054])
                    ("paused" variable nil (reparse-symbol indented_block_body) [7059 7073])
                    ("_debugInfo" variable nil (reparse-symbol indented_block_body) [7078 7095])
                    ("_suppressAlreadyCalled" variable nil (reparse-symbol indented_block_body) [7100 7130])
                    ("_runningCallbacks" variable nil (reparse-symbol indented_block_body) [7304 7329])
                    ("debug" variable nil (reparse-symbol indented_block_body) [7433 7446])
                    ("_chainedTo" variable nil (reparse-symbol indented_block_body) [7452 7469])
                    ("__init__" function
                       (:suite 
                          ( ("\"\"\"
        Initialize a L{Deferred}.

        @param canceller: a callable used to stop the pending operation
            scheduled by this L{Deferred} when L{Deferred.cancel} is
            invoked. The canceller will be passed the deferred whose
            cancelation is requested (i.e., self).

            If a canceller is not given, or does not invoke its argument's
            C{callback} or C{errback} method, L{Deferred.cancel} will
            invoke L{Deferred.errback} with a L{CancelledError}.

            Note that if a canceller is not given, C{callback} or
            C{errback} may still be invoked exactly once, even though
            defer.py will have already invoked C{errback}, as described
            above.  This allows clients of code which returns a L{Deferred}
            to cancel it without requiring the L{Deferred} instantiator to
            provide any specific implementation support for cancellation.
            New in 10.1.

        @type canceller: a 1-argument callable which takes a L{Deferred}. The
            return result is ignored.
        \"\"\"" code nil (reparse-symbol indented_block_body) [7519 8617])
                            ("self" variable nil (reparse-symbol indented_block_body) [8626 8645])
                            ("self" variable nil (reparse-symbol indented_block_body) [8654 8681])
                            ("if" code nil (reparse-symbol indented_block_body) [8690 8815]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [7488 7492])
                            ("canceller" variable nil (reparse-symbol function_parameters) [7494 7503]))                          
                        :documentation "
        Initialize a L{Deferred}.

        @param canceller: a callable used to stop the pending operation
            scheduled by this L{Deferred} when L{Deferred.cancel} is
            invoked. The canceller will be passed the deferred whose
            cancelation is requested (i.e., self).

            If a canceller is not given, or does not invoke its argument's
            C{callback} or C{errback} method, L{Deferred.cancel} will
            invoke L{Deferred.errback} with a L{CancelledError}.

            Note that if a canceller is not given, C{callback} or
            C{errback} may still be invoked exactly once, even though
            defer.py will have already invoked C{errback}, as described
            above.  This allows clients of code which returns a L{Deferred}
            to cancel it without requiring the L{Deferred} instantiator to
            provide any specific implementation support for cancellation.
            New in 10.1.

        @type canceller: a 1-argument callable which takes a L{Deferred}. The
            return result is ignored.
        "
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [7475 8815])
                    ("addCallbacks" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [8838 8842])
                            ("callback" variable nil (reparse-symbol function_parameters) [8844 8852])
                            ("errback" variable nil (reparse-symbol function_parameters) [8854 8861])
                            ("callbackArgs" variable nil (reparse-symbol function_parameters) [8889 8901])
                            ("callbackKeywords" variable nil (reparse-symbol function_parameters) [8908 8924])
                            ("errbackArgs" variable nil (reparse-symbol function_parameters) [8952 8963])
                            ("errbackKeywords" variable nil (reparse-symbol function_parameters) [8970 8985]))                          
                        :documentation "
        Add a pair of callbacks (success and error) to this L{Deferred}.

        These will be executed when the 'master' callback is run.

        @return: C{self}.
        @rtype: a L{Deferred}
        ")
                        (reparse-symbol indented_block_body) [8821 9542])
                    ("addCallback" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [9564 9568])
                            ("callback" variable nil (reparse-symbol function_parameters) [9570 9578])
                            ("args" variable nil (reparse-symbol function_parameters) [9580 9585])
                            ("kw" variable nil (reparse-symbol function_parameters) [9587 9591]))                          
                        :documentation "
        Convenience method for adding just a callback.

        See L{addCallbacks}.
        ")
                        (reparse-symbol indented_block_body) [9548 9819])
                    ("addErrback" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [9840 9844])
                            ("errback" variable nil (reparse-symbol function_parameters) [9846 9853])
                            ("args" variable nil (reparse-symbol function_parameters) [9855 9860])
                            ("kw" variable nil (reparse-symbol function_parameters) [9862 9866]))                          
                        :documentation "
        Convenience method for adding just an errback.

        See L{addCallbacks}.
        ")
                        (reparse-symbol indented_block_body) [9825 10134])
                    ("addBoth" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [10152 10156])
                            ("callback" variable nil (reparse-symbol function_parameters) [10158 10166])
                            ("args" variable nil (reparse-symbol function_parameters) [10168 10173])
                            ("kw" variable nil (reparse-symbol function_parameters) [10175 10179]))                          
                        :documentation "
        Convenience method for adding a single callable as both a callback
        and an errback.

        See L{addCallbacks}.
        ")
                        (reparse-symbol indented_block_body) [10140 10532])
                    ("addTimeout" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [10553 10557])
                            ("timeout" variable nil (reparse-symbol function_parameters) [10559 10566])
                            ("clock" variable nil (reparse-symbol function_parameters) [10568 10573])
                            ("onTimeoutCancel" variable nil (reparse-symbol function_parameters) [10575 10590]))                          
                        :documentation "
        Time out this L{Deferred} by scheduling it to be cancelled after
        C{timeout} seconds.

        The timeout encompasses all the callbacks and errbacks added to this
        L{defer.Deferred} before the call to L{addTimeout}, and none added
        after the call.

        If this L{Deferred} gets timed out, it errbacks with a L{TimeoutError},
        unless a cancelable function was passed to its initialization or unless
        a different C{onTimeoutCancel} callable is provided.

        @param timeout: number of seconds to wait before timing out this
            L{Deferred}
        @type timeout: L{int}

        @param clock: The object which will be used to schedule the timeout.
        @type clock: L{twisted.internet.interfaces.IReactorTime}

        @param onTimeoutCancel: A callable which is called immediately after
            this L{Deferred} times out, and not if this L{Deferred} is
            otherwise cancelled before the timeout. It takes an arbitrary
            value, which is the value of this L{Deferred} at that exact point
            in time (probably a L{CancelledError} L{Failure}), and the
            C{timeout}.  The default callable (if none is provided) will
            translate a L{CancelledError} L{Failure} into a L{TimeoutError}.
        @type onTimeoutCancel: L{callable}

        @return: C{self}.
        @rtype: a L{Deferred}

        @since: 16.5
        ")
                        (reparse-symbol indented_block_body) [10538 12873])
                    ("chainDeferred" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [12897 12901])
                            ("d" variable nil (reparse-symbol function_parameters) [12903 12904]))                          
                        :documentation "
        Chain another L{Deferred} to this L{Deferred}.

        This method adds callbacks to this L{Deferred} to call C{d}'s callback
        or errback, as appropriate. It is merely a shorthand way of performing
        the following::

            self.addCallbacks(d.callback, d.errback)

        When you chain a deferred d2 to another deferred d1 with
        d1.chainDeferred(d2), you are making d2 participate in the callback
        chain of d1. Thus any event that fires d1 will also fire d2.
        However, the converse is B{not} true; if d2 is fired d1 will not be
        affected.

        Note that unlike the case where chaining is caused by a L{Deferred}
        being returned from a callback, it is possible to cause the call
        stack size limit to be exceeded by chaining many L{Deferred}s
        together with C{chainDeferred}.

        @return: C{self}.
        @rtype: a L{Deferred}
        ")
                        (reparse-symbol indented_block_body) [12879 13929])
                    ("callback" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [13948 13952])
                            ("result" variable nil (reparse-symbol function_parameters) [13954 13960]))                          
                        :documentation "
        Run all success callbacks that have been added to this L{Deferred}.

        Each callback will have its result passed as the first argument to
        the next; this way, the callbacks act as a 'processing chain'.  If
        the success-callback returns a L{Failure} or raises an L{Exception},
        processing will continue on the *error* callback chain.  If a
        callback (or errback) returns another L{Deferred}, this L{Deferred}
        will be chained to it (and further callbacks will not run until that
        L{Deferred} has a result).

        An instance of L{Deferred} may only have either L{callback} or
        L{errback} called on it, and only once.

        @param result: The object which will be passed to the first callback
            added to this L{Deferred} (via L{addCallback}).

        @raise AlreadyCalledError: If L{callback} or L{errback} has already been
            called on this L{Deferred}.
        ")
                        (reparse-symbol indented_block_body) [13935 15017])
                    ("errback" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [15035 15039])
                            ("fail" variable nil (reparse-symbol function_parameters) [15041 15045]))                          
                        :documentation "
        Run all error callbacks that have been added to this L{Deferred}.

        Each callback will have its result passed as the first
        argument to the next; this way, the callbacks act as a
        'processing chain'. Also, if the error-callback returns a non-Failure
        or doesn't raise an L{Exception}, processing will continue on the
        *success*-callback chain.

        If the argument that's passed to me is not a L{failure.Failure} instance,
        it will be embedded in one. If no argument is passed, a
        L{failure.Failure} instance will be created based on the current
        traceback stack.

        Passing a string as `fail' is deprecated, and will be punished with
        a warning message.

        An instance of L{Deferred} may only have either L{callback} or
        L{errback} called on it, and only once.

        @param fail: The L{Failure} object which will be passed to the first
            errback added to this L{Deferred} (via L{addErrback}).
            Alternatively, a L{Exception} instance from which a L{Failure} will
            be constructed (with no traceback) or L{None} to create a L{Failure}
            instance from the current exception state (with a traceback).

        @raise AlreadyCalledError: If L{callback} or L{errback} has already been
            called on this L{Deferred}.

        @raise NoCurrentExceptionError: If C{fail} is L{None} but there is
            no current exception state.
        ")
                        (reparse-symbol indented_block_body) [15023 16767])
                    ("pause" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [16783 16787]))                          
                        :documentation "
        Stop processing on a L{Deferred} until L{unpause}() is called.
        ")
                        (reparse-symbol indented_block_body) [16773 16923])
                    ("unpause" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [16941 16945]))                          
                        :documentation "
        Process all callbacks made since L{pause}() was called.
        ")
                        (reparse-symbol indented_block_body) [16929 17174])
                    ("cancel" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [17191 17195]))                          
                        :documentation "
        Cancel this L{Deferred}.

        If the L{Deferred} has not yet had its C{errback} or C{callback} method
        invoked, call the canceller function provided to the constructor. If
        that function does not invoke C{callback} or C{errback}, or if no
        canceller function was provided, errback with L{CancelledError}.

        If this L{Deferred} is waiting on another L{Deferred}, forward the
        cancellation to the other L{Deferred}.
        ")
                        (reparse-symbol indented_block_body) [17180 18359])
                    ("_startRunCallbacks" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [18388 18392])
                            ("result" variable nil (reparse-symbol function_parameters) [18394 18400]))                          )
                        (reparse-symbol indented_block_body) [18365 19083])
                    ("_continuation" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [19107 19111]))                          
                        :documentation "
        Build a tuple of callback and errback with L{_CONTINUE}.
        ")
                        (reparse-symbol indented_block_body) [19089 19291])
                    ("_runCallbacks" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [19315 19319]))                          
                        :documentation "
        Run the chain of callbacks once a result is available.

        This consists of a simple loop over all of the callbacks, calling each
        with the current result and making the current result equal to the
        return value (or raised exception) of that call.

        If L{_runningCallbacks} is true, this loop won't run at all, since
        it is already running above us on the call stack.  If C{self.paused} is
        true, the loop also won't run, because that's what it means to be
        paused.

        The loop will terminate before processing all of the callbacks if a
        L{Deferred} without a result is encountered.

        If a L{Deferred} I{with} a result is encountered, that result is taken
        and the loop proceeds.

        @note: The implementation is complicated slightly by the fact that
            chaining (associating two L{Deferred}s with each other such that one
            will wait for the result of the other, as happens when a Deferred is
            returned from a callback on another L{Deferred}) is supported
            iteratively rather than recursively, to avoid running out of stack
            frames when processing long chains.
        ")
                        (reparse-symbol indented_block_body) [19297 26026])
                    ("__str__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [26044 26048]))                          
                        :documentation "
        Return a string representation of this C{Deferred}.
        ")
                        (reparse-symbol indented_block_body) [26032 26553])
                    ("__repr__" variable nil (reparse-symbol indented_block_body) [26557 26575])
                    ("__iter__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [26595 26599]))                          )
                        (reparse-symbol indented_block_body) [26582 26622])
                    ("send" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [26637 26641])
                            ("value" variable nil (reparse-symbol function_parameters) [26643 26648]))                          )
                        (reparse-symbol indented_block_body) [26628 27152])
                    ("__await__" variable nil (reparse-symbol indented_block_body) [27198 27218])
                    ("__next__" variable nil (reparse-symbol indented_block_body) [27223 27238])
                    ("asFuture" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [27258 27262])
                            ("loop" variable nil (reparse-symbol function_parameters) [27264 27268]))                          
                        :documentation "
        Adapt a L{Deferred} into a L{asyncio.Future} which is bound to C{loop}.

        @note: converting a L{Deferred} to an L{asyncio.Future} consumes both
            its result and its errors, so this method implicitly converts
            C{self} into a L{Deferred} firing with L{None}, regardless of what
            its result previously would have been.

        @since: Twisted 17.5.0

        @param loop: The asyncio event loop to bind the L{asyncio.Future} to.
        @type loop: L{asyncio.AbstractEventLoop} or similar

        @param deferred: The Deferred to adapt.
        @type deferred: L{Deferred}

        @return: A Future which will fire when the Deferred fires.
        @rtype: L{asyncio.Future}
        ")
                        (reparse-symbol indented_block_body) [27245 28715])
                    ("fromFuture" function
                       (:documentation "
        Adapt an L{asyncio.Future} to a L{Deferred}.

        @note: This creates a L{Deferred} from a L{asyncio.Future}, I{not} from
            a C{coroutine}; in other words, you will need to call
            L{asyncio.async}, L{asyncio.ensure_future},
            L{asyncio.AbstractEventLoop.create_task} or create an
            L{asyncio.Task} yourself to get from a C{coroutine} to a
            L{asyncio.Future} if what you have is an awaitable coroutine and
            not a L{asyncio.Future}.  (The length of this list of techniques is
            exactly why we have left it to the caller!)

        @since: Twisted 17.5.0

        @param future: The Future to adapt.
        @type future: L{asyncio.Future}

        @return: A Deferred which will fire when the Future fires.
        @rtype: L{Deferred}
        "
                        :arguments 
                          ( ("cls" variable nil (reparse-symbol function_parameters) [28753 28756])
                            ("future" variable nil (reparse-symbol function_parameters) [28758 28764]))                          
                        :decorators 
                          ( ("classmethod" function (:type "decorator") nil nil))                          )
                        (reparse-symbol indented_block_body) [28721 30260]))                  
                :type "class")
                nil [5052 30260])
            ("_cancelledToTimedOutError" function
               (:documentation "
    A default translation function that translates L{Failure}s that are
    L{CancelledError}s to L{TimeoutError}s.

    @param value: Anything
    @type value: Anything

    @param timeout: The timeout
    @type timeout: L{int}

    @rtype: C{value}
    @raise: L{TimeoutError}

    @since: 16.5
    "
                :arguments 
                  ( ("value" variable nil (reparse-symbol function_parameters) [30293 30298])
                    ("timeout" variable nil (reparse-symbol function_parameters) [30300 30307]))                  )
                nil [30263 30766])
            ("ensureDeferred" function
               (:documentation "
    Schedule the execution of a coroutine that awaits/yields from L{Deferred}s,
    wrapping it in a L{Deferred} that will fire on success/failure of the
    coroutine. If a Deferred is passed to this function, it will be returned
    directly (mimicing C{asyncio}'s C{ensure_future} function).

    Coroutine functions return a coroutine object, similar to how generators
    work. This function turns that coroutine into a Deferred, meaning that it
    can be used in regular Twisted code. For example::

        import treq
        from twisted.internet.defer import ensureDeferred
        from twisted.internet.task import react

        async def crawl(pages):
            results = {}
            for page in pages:
                results[page] = await treq.content(await treq.get(page))
            return results

        def main(reactor):
            pages = [
                \"http://localhost:8080\"
            ]
            d = ensureDeferred(crawl(pages))
            d.addCallback(print)
            return d

        react(main)

    @param coro: The coroutine object to schedule, or a L{Deferred}.
    @type coro: A Python 3.5+ C{async def} C{coroutine}, a Python 3.3+
        C{yield from} using L{types.GeneratorType}, or a L{Deferred}.

    @rtype: L{Deferred}
    "
                :arguments 
                  ( ("coro" variable nil (reparse-symbol function_parameters) [30788 30792]))                  )
                nil [30769 32627])
            ("DebugInfo" type
               (:documentation "
    Deferred debug helper.
    "
                :members 
                  ( ("failResult" variable nil (reparse-symbol indented_block_body) [32707 32724])
                    ("_getDebugTracebacks" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [32754 32758]))                          )
                        (reparse-symbol indented_block_body) [32730 33174])
                    ("__del__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [33192 33196]))                          
                        :documentation "
        Print tracebacks and die.

        If the *last* (and I do mean *last*) callback leaves me in an error
        state, print a traceback (if said errback is a L{Failure}).
        ")
                        (reparse-symbol indented_block_body) [33180 33979]))                  
                :type "class")
                nil [32642 33979])
            ("FirstError" type
               (:documentation "
    First error to occur in a L{DeferredList} if C{fireOnOneErrback} is set.

    @ivar subFailure: The L{Failure} that occurred.
    @type subFailure: L{Failure}

    @ivar index: The index of the L{Deferred} in the L{DeferredList} where
        it happened.
    @type index: L{int}
    "
                :superclasses ("Exception")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("Exception" code nil (reparse-symbol indented_block_body) [34371 34411])
                            ("self" variable nil (reparse-symbol indented_block_body) [34420 34445])
                            ("self" variable nil (reparse-symbol indented_block_body) [34454 34472]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [34340 34344])
                            ("failure" variable nil (reparse-symbol function_parameters) [34346 34353])
                            ("index" variable nil (reparse-symbol function_parameters) [34355 34360]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [34327 34473])
                    ("__repr__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [34492 34496]))                          
                        :documentation "
        The I{repr} of L{FirstError} instances includes the repr of the
        wrapped failure's exception and the index of the L{FirstError}.
        ")
                        (reparse-symbol indented_block_body) [34479 34742])
                    ("__str__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [34760 34764]))                          
                        :documentation "
        The I{str} of L{FirstError} instances includes the I{str} of the
        entire wrapped failure (including its traceback and exception) and
        the index of the L{FirstError}.
        ")
                        (reparse-symbol indented_block_body) [34748 35048])
                    ("__cmp__" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [35066 35070])
                            ("other" variable nil (reparse-symbol function_parameters) [35072 35077]))                          
                        :documentation "
        Comparison between L{FirstError} and other L{FirstError} instances
        is defined as the comparison of the index and sub-failure of each
        instance.  L{FirstError} instances don't compare equal to anything
        that isn't a L{FirstError} instance.

        @since: 8.2
        ")
                        (reparse-symbol indented_block_body) [35054 35574]))                  
                :type "class")
                nil [33994 35574])
            ("DeferredList" type
               (:documentation "
    L{DeferredList} is a tool for collecting the results of several Deferreds.

    This tracks a list of L{Deferred}s for their results, and makes a single
    callback when they have all completed.  By default, the ultimate result is a
    list of (success, result) tuples, 'success' being a boolean.
    L{DeferredList} exposes the same API that L{Deferred} does, so callbacks and
    errbacks can be added to it in the same way.

    L{DeferredList} is implemented by adding callbacks and errbacks to each
    L{Deferred} in the list passed to it.  This means callbacks and errbacks
    added to the Deferreds before they are passed to L{DeferredList} will change
    the result that L{DeferredList} sees (i.e., L{DeferredList} is not special).
    Callbacks and errbacks can also be added to the Deferreds after they are
    passed to L{DeferredList} and L{DeferredList} may change the result that
    they see.

    See the documentation for the C{__init__} arguments for more information.

    @ivar _deferredList: The L{list} of L{Deferred}s to track.
    "
                :superclasses ("Deferred")
                :members 
                  ( ("fireOnOneCallback" variable nil (reparse-symbol indented_block_body) [36688 36713])
                    ("fireOnOneErrback" variable nil (reparse-symbol indented_block_body) [36718 36742])
                    ("__init__" function
                       (:suite 
                          ( ("\"\"\"
        Initialize a DeferredList.

        @param deferredList: The list of deferreds to track.
        @type deferredList:  L{list} of L{Deferred}s

        @param fireOnOneCallback: (keyword param) a flag indicating that this
            L{DeferredList} will fire when the first L{Deferred} in
            C{deferredList} fires with a non-failure result without waiting for
            any of the other Deferreds.  When this flag is set, the DeferredList
            will fire with a two-tuple: the first element is the result of the
            Deferred which fired; the second element is the index in
            C{deferredList} of that Deferred.
        @type fireOnOneCallback: L{bool}

        @param fireOnOneErrback: (keyword param) a flag indicating that this
            L{DeferredList} will fire when the first L{Deferred} in
            C{deferredList} fires with a failure result without waiting for any
            of the other Deferreds.  When this flag is set, if a Deferred in the
            list errbacks, the DeferredList will errback with a L{FirstError}
            failure wrapping the failure of that Deferred.
        @type fireOnOneErrback: L{bool}

        @param consumeErrors: (keyword param) a flag indicating that failures in
            any of the included L{Deferred}s should not be propagated to
            errbacks added to the individual L{Deferred}s after this
            L{DeferredList} is constructed.  After constructing the
            L{DeferredList}, any errors in the individual L{Deferred}s will be
            converted to a callback result of L{None}.  This is useful to
            prevent spurious 'Unhandled error in Deferred' messages from being
            logged.  This does not prevent C{fireOnOneErrback} from working.
        @type consumeErrors: L{bool}
        \"\"\"" code nil (reparse-symbol indented_block_body) [36877 38707])
                            ("self" variable nil (reparse-symbol indented_block_body) [38716 38755])
                            ("self" code nil (reparse-symbol indented_block_body) [38764 38814])
                            ("Deferred" code nil (reparse-symbol indented_block_body) [38823 38846])
                            ("if" code nil (reparse-symbol indented_block_body) [38855 38957])
                            ("self" variable nil (reparse-symbol indented_block_body) [39179 39221])
                            ("self" variable nil (reparse-symbol indented_block_body) [39230 39270])
                            ("self" variable nil (reparse-symbol indented_block_body) [39279 39313])
                            ("self" variable nil (reparse-symbol indented_block_body) [39322 39344])
                            ("index" variable nil (reparse-symbol indented_block_body) [39354 39363])
                            ("for" code nil (reparse-symbol indented_block_body) [39372 39635]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [36761 36765])
                            ("deferredList" variable nil (reparse-symbol function_parameters) [36767 36779])
                            ("fireOnOneCallback" variable nil (reparse-symbol function_parameters) [36781 36798])
                            ("fireOnOneErrback" variable nil (reparse-symbol function_parameters) [36823 36839])
                            ("consumeErrors" variable nil (reparse-symbol function_parameters) [36847 36860]))                          
                        :documentation "
        Initialize a DeferredList.

        @param deferredList: The list of deferreds to track.
        @type deferredList:  L{list} of L{Deferred}s

        @param fireOnOneCallback: (keyword param) a flag indicating that this
            L{DeferredList} will fire when the first L{Deferred} in
            C{deferredList} fires with a non-failure result without waiting for
            any of the other Deferreds.  When this flag is set, the DeferredList
            will fire with a two-tuple: the first element is the result of the
            Deferred which fired; the second element is the index in
            C{deferredList} of that Deferred.
        @type fireOnOneCallback: L{bool}

        @param fireOnOneErrback: (keyword param) a flag indicating that this
            L{DeferredList} will fire when the first L{Deferred} in
            C{deferredList} fires with a failure result without waiting for any
            of the other Deferreds.  When this flag is set, if a Deferred in the
            list errbacks, the DeferredList will errback with a L{FirstError}
            failure wrapping the failure of that Deferred.
        @type fireOnOneErrback: L{bool}

        @param consumeErrors: (keyword param) a flag indicating that failures in
            any of the included L{Deferred}s should not be propagated to
            errbacks added to the individual L{Deferred}s after this
            L{DeferredList} is constructed.  After constructing the
            L{DeferredList}, any errors in the individual L{Deferred}s will be
            converted to a callback result of L{None}.  This is useful to
            prevent spurious 'Unhandled error in Deferred' messages from being
            logged.  This does not prevent C{fireOnOneErrback} from working.
        @type consumeErrors: L{bool}
        "
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [36748 39635])
                    ("_cbDeferred" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [39657 39661])
                            ("result" variable nil (reparse-symbol function_parameters) [39663 39669])
                            ("index" variable nil (reparse-symbol function_parameters) [39671 39676])
                            ("succeeded" variable nil (reparse-symbol function_parameters) [39678 39687]))                          
                        :documentation "
        (internal) Callback for when one of my deferreds fires.
        ")
                        (reparse-symbol indented_block_body) [39641 40355])
                    ("cancel" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [40372 40376]))                          
                        :documentation "
        Cancel this L{DeferredList}.

        If the L{DeferredList} hasn't fired yet, cancel every L{Deferred} in
        the list.

        If the L{DeferredList} has fired, including the case where the
        C{fireOnOneCallback}/C{fireOnOneErrback} flag is set and the
        L{DeferredList} fires because one L{Deferred} in the list fires with a
        non-failure/failure result, do nothing in the C{cancel} method.
        ")
                        (reparse-symbol indented_block_body) [40361 41114]))                  
                :type "class")
                nil [35577 41114])
            ("_parseDListResult" function (:arguments 
              ( ("l" variable nil (reparse-symbol function_parameters) [41139 41140])
                ("fireOnOneErrback" variable nil (reparse-symbol function_parameters) [41142 41158]))              ) nil [41117 41274])
            ("gatherResults" function
               (:documentation "
    Returns, via a L{Deferred}, a list with the results of the given
    L{Deferred}s - in effect, a \"join\" of multiple deferred operations.

    The returned L{Deferred} will fire when I{all} of the provided L{Deferred}s
    have fired, or when any one of them has failed.

    This method can be cancelled by calling the C{cancel} method of the
    L{Deferred}, all the L{Deferred}s in the list will be cancelled.

    This differs from L{DeferredList} in that you don't need to parse
    the result for success/failure.

    @type deferredList:  L{list} of L{Deferred}s

    @param consumeErrors: (keyword param) a flag, defaulting to False,
        indicating that failures in any of the given L{Deferred}s should not be
        propagated to errbacks added to the individual L{Deferred}s after this
        L{gatherResults} invocation.  Any such errors in the individual
        L{Deferred}s will be converted to a callback result of L{None}.  This
        is useful to prevent spurious 'Unhandled error in Deferred' messages
        from being logged.  This parameter is available since 11.1.0.
    @type consumeErrors: L{bool}
    "
                :arguments 
                  ( ("deferredList" variable nil (reparse-symbol function_parameters) [41295 41307])
                    ("consumeErrors" variable nil (reparse-symbol function_parameters) [41309 41322]))                  )
                nil [41277 42653])
            ("SUCCESS" variable nil nil [42695 42709])
            ("FAILURE" variable nil nil [42710 42725])
            ("waitForDeferred" type
               (:documentation "
    See L{deferredGenerator}.
    "
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("warnings" code nil (reparse-symbol indented_block_body) [42866 43090])
                            ("if" code nil (reparse-symbol indented_block_body) [43100 43228])
                            ("self" variable nil (reparse-symbol indented_block_body) [43236 43246]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [42848 42852])
                            ("d" variable nil (reparse-symbol function_parameters) [42854 42855]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [42835 43247])
                    ("getResult" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [43267 43271]))                          )
                        (reparse-symbol indented_block_body) [43253 43395]))                  
                :type "class")
                nil [42761 43395])
            ("_deferGenerator" function
               (:documentation "
    See L{deferredGenerator}.
    "
                :arguments 
                  ( ("g" variable nil (reparse-symbol function_parameters) [43418 43419])
                    ("deferred" variable nil (reparse-symbol function_parameters) [43421 43429]))                  )
                nil [43398 45311])
            ("" code nil nil [45325 45409])
            ("deferredGenerator" function
               (:documentation "
    L{deferredGenerator} and L{waitForDeferred} help you write
    L{Deferred}-using code that looks like a regular sequential function.
    Consider the use of L{inlineCallbacks} instead, which can accomplish
    the same thing in a more concise manner.

    There are two important functions involved: L{waitForDeferred}, and
    L{deferredGenerator}.  They are used together, like this::

        @deferredGenerator
        def thingummy():
            thing = waitForDeferred(makeSomeRequestResultingInDeferred())
            yield thing
            thing = thing.getResult()
            print(thing) #the result! hoorj!

    L{waitForDeferred} returns something that you should immediately yield; when
    your generator is resumed, calling C{thing.getResult()} will either give you
    the result of the L{Deferred} if it was a success, or raise an exception if it
    was a failure.  Calling C{getResult} is B{absolutely mandatory}.  If you do
    not call it, I{your program will not work}.

    L{deferredGenerator} takes one of these waitForDeferred-using generator
    functions and converts it into a function that returns a L{Deferred}. The
    result of the L{Deferred} will be the last value that your generator yielded
    unless the last value is a L{waitForDeferred} instance, in which case the
    result will be L{None}.  If the function raises an unhandled exception, the
    L{Deferred} will errback instead.  Remember that C{return result} won't work;
    use C{yield result; return} in place of that.

    Note that not yielding anything from your generator will make the L{Deferred}
    result in L{None}. Yielding a L{Deferred} from your generator is also an error
    condition; always yield C{waitForDeferred(d)} instead.

    The L{Deferred} returned from your deferred generator may also errback if your
    generator raised an exception.  For example::

        @deferredGenerator
        def thingummy():
            thing = waitForDeferred(makeSomeRequestResultingInDeferred())
            yield thing
            thing = thing.getResult()
            if thing == 'I love Twisted':
                # will become the result of the Deferred
                yield 'TWISTED IS GREAT!'
                return
            else:
                # will trigger an errback
                raise Exception('DESTROY ALL LIFE')

    Put succinctly, these functions connect deferred-using code with this 'fake
    blocking' style in both directions: L{waitForDeferred} converts from a
    L{Deferred} to the 'blocking' style, and L{deferredGenerator} converts from the
    'blocking' style to a L{Deferred}.
    "
                :arguments 
                  ( ("f" variable nil (reparse-symbol function_parameters) [45432 45433]))                  )
                nil [45410 48226])
            ("_DefGen_Return" type
               (:superclasses ("BaseException")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [48326 48344]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [48304 48308])
                            ("value" variable nil (reparse-symbol function_parameters) [48310 48315]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [48291 48345]))                  
                :type "class")
                nil [48250 48345])
            ("returnValue" function
               (:documentation "
    Return val from a L{inlineCallbacks} generator.

    Note: this is currently implemented by raising an exception
    derived from L{BaseException}.  You might want to change any
    'except:' clauses to an 'except Exception:' clause so as not to
    catch this exception.

    Also: while this function currently will work when called from
    within arbitrary functions called from within the generator, do
    not rely upon this behavior.
    "
                :arguments 
                  ( ("val" variable nil (reparse-symbol function_parameters) [48364 48367]))                  )
                nil [48348 48861])
            ("_inlineCallbacks" function
               (:documentation "
    See L{inlineCallbacks}.
    "
                :arguments 
                  ( ("result" variable nil (reparse-symbol function_parameters) [48885 48891])
                    ("g" variable nil (reparse-symbol function_parameters) [48893 48894])
                    ("deferred" variable nil (reparse-symbol function_parameters) [48896 48904]))                  )
                nil [48864 53081])
            ("inlineCallbacks" function
               (:documentation "
    inlineCallbacks helps you write L{Deferred}-using code that looks like a
    regular sequential function. For example::

        @inlineCallbacks
        def thingummy():
            thing = yield makeSomeRequestResultingInDeferred()
            print(thing)  # the result! hoorj!

    When you call anything that results in a L{Deferred}, you can simply yield it;
    your generator will automatically be resumed when the Deferred's result is
    available. The generator will be sent the result of the L{Deferred} with the
    'send' method on generators, or if the result was a failure, 'throw'.

    Things that are not L{Deferred}s may also be yielded, and your generator
    will be resumed with the same object sent back. This means C{yield}
    performs an operation roughly equivalent to L{maybeDeferred}.

    Your inlineCallbacks-enabled generator will return a L{Deferred} object, which
    will result in the return value of the generator (or will fail with a
    failure object if your generator raises an unhandled exception). Note that
    you can't use C{return result} to return a value; use C{returnValue(result)}
    instead. Falling off the end of the generator, or simply using C{return}
    will cause the L{Deferred} to have a result of L{None}.

    Be aware that L{returnValue} will not accept a L{Deferred} as a parameter.
    If you believe the thing you'd like to return could be a L{Deferred}, do
    this::

        result = yield result
        returnValue(result)

    The L{Deferred} returned from your deferred generator may errback if your
    generator raised an exception::

        @inlineCallbacks
        def thingummy():
            thing = yield makeSomeRequestResultingInDeferred()
            if thing == 'I love Twisted':
                # will become the result of the Deferred
                returnValue('TWISTED IS GREAT!')
            else:
                # will trigger an errback
                raise Exception('DESTROY ALL LIFE')

    If you are using Python 3.3 or later, it is possible to use the C{return}
    statement instead of L{returnValue}::

        @inlineCallbacks
        def loadData(url):
            response = yield makeRequest(url)
            return json.loads(response)
    "
                :arguments 
                  ( ("f" variable nil (reparse-symbol function_parameters) [53104 53105]))                  )
                nil [53084 55973])
            ("_ConcurrencyPrimitive" type
               (:superclasses ("object")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [56075 56092]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [56060 56064]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [56047 56093])
                    ("_releaseAndReturn" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [56121 56125])
                            ("r" variable nil (reparse-symbol function_parameters) [56127 56128]))                          )
                        (reparse-symbol indented_block_body) [56099 56171])
                    ("run" function
                       (:documentation "
        Acquire, run, release.

        This function takes a callable as its first argument and any
        number of other positional and keyword arguments.  When the
        lock or semaphore is acquired, the callable will be invoked
        with those arguments.

        The callable may return a L{Deferred}; if it does, the lock or
        semaphore won't be released until that L{Deferred} fires.

        @return: L{Deferred} of function result.
        "
                        :arguments 
                          ( ("args" variable nil (reparse-symbol function_parameters) [56185 56190])
                            ("kwargs" variable nil (reparse-symbol function_parameters) [56192 56200]))                          )
                        (reparse-symbol indented_block_body) [56177 57220]))                  
                :type "class")
                nil [56006 57220])
            ("DeferredLock" type
               (:documentation "
    A lock for event driven systems.

    @ivar locked: C{True} when this Lock has been acquired, false at all other
        times.  Do not change this value, but it is useful to examine for the
        equivalent of a \"non-blocking\" acquisition.
    "
                :superclasses ("_ConcurrencyPrimitive")
                :members 
                  ( ("locked" variable nil (reparse-symbol indented_block_body) [57534 57548])
                    ("_cancelAcquire" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [57574 57578])
                            ("d" variable nil (reparse-symbol function_parameters) [57580 57581]))                          
                        :documentation "
        Remove a deferred d from our waiting list, as the deferred has been
        canceled.

        Note: We do not need to wrap this in a try/except to catch d not
        being in self.waiting because this canceller will not be called if
        d has fired. release() pops a deferred out of self.waiting and
        calls it, so the canceller will no longer be called.

        @param d: The deferred that has been canceled.
        ")
                        (reparse-symbol indented_block_body) [57555 58070])
                    ("acquire" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [58088 58092]))                          
                        :documentation "
        Attempt to acquire the lock.  Returns a L{Deferred} that fires on
        lock acquisition with the L{DeferredLock} as the value.  If the lock
        is locked, then the Deferred is placed at the end of a waiting list.

        @return: a L{Deferred} which fires on lock acquisition.
        @rtype: a L{Deferred}
        ")
                        (reparse-symbol indented_block_body) [58076 58644])
                    ("release" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [58662 58666]))                          
                        :documentation "
        Release the lock.  If there is a waiting list, then the first
        L{Deferred} in that waiting list will be called back.

        Should be called by whomever did the L{acquire}() when the shared
        resource is free.
        ")
                        (reparse-symbol indented_block_body) [58650 59188]))                  
                :type "class")
                nil [57223 59188])
            ("DeferredSemaphore" type
               (:documentation "
    A semaphore for event driven systems.

    If you are looking into this as a means of limiting parallelism, you might
    find L{twisted.internet.task.Cooperator} more useful.

    @ivar limit: At most this many users may acquire this semaphore at
        once.
    @type limit: L{int}

    @ivar tokens: The difference between C{limit} and the number of users
        which have currently acquired this semaphore.
    @type tokens: L{int}
    "
                :superclasses ("_ConcurrencyPrimitive")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("\"\"\"
        @param tokens: initial value of L{tokens} and L{limit}
        @type tokens: L{int}
        \"\"\"" code nil (reparse-symbol indented_block_body) [59740 59847])
                            ("_ConcurrencyPrimitive" code nil (reparse-symbol indented_block_body) [59856 59892])
                            ("if" code nil (reparse-symbol indented_block_body) [59901 59987])
                            ("self" variable nil (reparse-symbol indented_block_body) [59995 60015])
                            ("self" variable nil (reparse-symbol indented_block_body) [60024 60043]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [59717 59721])
                            ("tokens" variable nil (reparse-symbol function_parameters) [59723 59729]))                          
                        :documentation "
        @param tokens: initial value of L{tokens} and L{limit}
        @type tokens: L{int}
        "
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [59704 60044])
                    ("_cancelAcquire" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [60069 60073])
                            ("d" variable nil (reparse-symbol function_parameters) [60075 60076]))                          
                        :documentation "
        Remove a deferred d from our waiting list, as the deferred has been
        canceled.

        Note: We do not need to wrap this in a try/except to catch d not
        being in self.waiting because this canceller will not be called if
        d has fired. release() pops a deferred out of self.waiting and
        calls it, so the canceller will no longer be called.

        @param d: The deferred that has been canceled.
        ")
                        (reparse-symbol indented_block_body) [60050 60565])
                    ("acquire" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [60583 60587]))                          
                        :documentation "
        Attempt to acquire the token.

        @return: a L{Deferred} which fires on token acquisition.
        ")
                        (reparse-symbol indented_block_body) [60571 61028])
                    ("release" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [61046 61050]))                          
                        :documentation "
        Release the token.

        Should be called by whoever did the L{acquire}() when the shared
        resource is free.
        ")
                        (reparse-symbol indented_block_body) [61034 61520]))                  
                :type "class")
                nil [59191 61520])
            ("QueueOverflow" type
               (:superclasses ("Exception")
                :members 
                  ( ("pass" code nil (reparse-symbol indented_block_body) [61559 61563]))                  
                :type "class")
                nil [61523 61564])
            ("QueueUnderflow" type
               (:superclasses ("Exception")
                :members 
                  ( ("pass" code nil (reparse-symbol indented_block_body) [61604 61608]))                  
                :type "class")
                nil [61567 61609])
            ("DeferredQueue" type
               (:documentation "
    An event driven queue.

    Objects may be added as usual to this queue.  When an attempt is
    made to retrieve an object when the queue is empty, a L{Deferred} is
    returned which will fire when an object becomes available.

    @ivar size: The maximum number of objects to allow into the queue
    at a time.  When an attempt to add a new object would exceed this
    limit, L{QueueOverflow} is raised synchronously.  L{None} for no limit.

    @ivar backlog: The maximum number of L{Deferred} gets to allow at
    one time.  When an attempt is made to get an object which would
    exceed this limit, L{QueueUnderflow} is raised synchronously.  L{None}
    for no limit.
    "
                :superclasses ("object")
                :members 
                  ( ("__init__" function
                       (:suite 
                          ( ("self" variable nil (reparse-symbol indented_block_body) [62397 62414])
                            ("self" variable nil (reparse-symbol indented_block_body) [62423 62440])
                            ("self" variable nil (reparse-symbol indented_block_body) [62449 62465])
                            ("self" variable nil (reparse-symbol indented_block_body) [62474 62496]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [62357 62361])
                            ("size" variable nil (reparse-symbol function_parameters) [62363 62367])
                            ("backlog" variable nil (reparse-symbol function_parameters) [62374 62381]))                          
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [62344 62497])
                    ("_cancelGet" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [62518 62522])
                            ("d" variable nil (reparse-symbol function_parameters) [62524 62525]))                          
                        :documentation "
        Remove a deferred d from our waiting list, as the deferred has been
        canceled.

        Note: We do not need to wrap this in a try/except to catch d not
        being in self.waiting because this canceller will not be called if
        d has fired. put() pops a deferred out of self.waiting and calls
        it, so the canceller will no longer be called.

        @param d: The deferred that has been canceled.
        ")
                        (reparse-symbol indented_block_body) [62503 63010])
                    ("put" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [63024 63028])
                            ("obj" variable nil (reparse-symbol function_parameters) [63030 63033]))                          
                        :documentation "
        Add an object to this queue.

        @raise QueueOverflow: Too many objects are in this queue.
        ")
                        (reparse-symbol indented_block_body) [63016 63385])
                    ("get" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [63399 63403]))                          
                        :documentation "
        Attempt to retrieve and remove an object from the queue.

        @return: a L{Deferred} which fires with the next object available in
        the queue.

        @raise QueueUnderflow: Too many (more than C{backlog})
        L{Deferred}s are already waiting for an object from this queue.
        ")
                        (reparse-symbol indented_block_body) [63391 64029]))                  
                :type "class")
                nil [61612 64029])
            ("AlreadyTryingToLockError" type
               (:documentation "
    Raised when L{DeferredFilesystemLock.deferUntilLocked} is called twice on a
    single L{DeferredFilesystemLock}.
    "
                :superclasses ("Exception")
                :type "class")
                nil [64032 64209])
            ("DeferredFilesystemLock" type
               (:documentation "
    A L{FilesystemLock} that allows for a L{Deferred} to be fired when the lock is
    acquired.

    @ivar _scheduler: The object in charge of scheduling retries. In this
        implementation this is parameterized for testing.

    @ivar _interval: The retry interval for an L{IReactorTime} based scheduler.

    @ivar _tryLockCall: A L{DelayedCall} based on C{_interval} that will manage
        the next retry for acquiring the lock.

    @ivar _timeoutCall: A L{DelayedCall} based on C{deferUntilLocked}'s timeout
        argument.  This is in charge of timing out our attempt to acquire the
        lock.
    "
                :superclasses ("lockfile.FilesystemLock")
                :members 
                  ( ("_interval" variable nil (reparse-symbol indented_block_body) [64899 64912])
                    ("_tryLockCall" variable nil (reparse-symbol indented_block_body) [64917 64936])
                    ("_timeoutCall" variable nil (reparse-symbol indented_block_body) [64941 64960])
                    ("__init__" function
                       (:suite 
                          ( ("\"\"\"
        @param name: The name of the lock to acquire
        @param scheduler: An object which provides L{IReactorTime}
        \"\"\"" code nil (reparse-symbol indented_block_body) [65017 65152])
                            ("lockfile" code nil (reparse-symbol indented_block_body) [65161 65205])
                            ("if" code nil (reparse-symbol indented_block_body) [65215 65318])
                            ("self" variable nil (reparse-symbol indented_block_body) [65327 65354]))                          
                        :parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [64980 64984])
                            ("name" variable nil (reparse-symbol function_parameters) [64986 64990])
                            ("scheduler" variable nil (reparse-symbol function_parameters) [64992 65001]))                          
                        :documentation "
        @param name: The name of the lock to acquire
        @param scheduler: An object which provides L{IReactorTime}
        "
                        :constructor-flag t)
                        (reparse-symbol indented_block_body) [64967 65355])
                    ("deferUntilLocked" function
                       (:parent "dummy"
                        :arguments 
                          ( ("self" variable nil (reparse-symbol function_parameters) [65382 65386])
                            ("timeout" variable nil (reparse-symbol function_parameters) [65388 65395]))                          
                        :documentation "
        Wait until we acquire this lock.  This method is not safe for
        concurrent use.

        @type timeout: L{float} or L{int}
        @param timeout: the number of seconds after which to time out if the
            lock has not been acquired.

        @return: a L{Deferred} which will callback when the lock is acquired, or
            errback with a L{TimeoutError} after timing out or an
            L{AlreadyTryingToLockError} if the L{deferUntilLocked} has already
            been called and not successfully locked the file.
        ")
                        (reparse-symbol indented_block_body) [65361 67653]))                  
                :type "class")
                nil [64212 67653])
            ("__all__" variable nil nil [67656 68085]))          
      :file "defer.py"
      :pointmax 68087
      :fsize 68086
      :lastmodtime '(22883 30004 924067 0)
      :unmatched-syntax '((INDENT_BLOCK 52069 . 52128) (NEWLINE 52068 . 52069) (COLON 52067 . 52068) (EXCEPT 52061 . 52067) (INDENT_BLOCK 50306 . 52053) (NEWLINE 49795 . 49796) (COLON 49794 . 49795) (AS 49790 . 49792) (EXCEPT 49768 . 49774) (INDENT_BLOCK 49675 . 49760) (NEWLINE 49620 . 49621) (COLON 49619 . 49620) (TRY 49295 . 49298) (AS 49615 . 49617))))
  :file "!home!harlan!.local!lib!python2.7!site-packages!twisted!internet!semantic.cache"
  :semantic-tag-version "2.0"
  :semanticdb-version "2.2")
